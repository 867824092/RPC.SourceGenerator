using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RPC.Server.SourceGenerator {
    [Generator]
    public class HelloSourceGenerator : ISourceGenerator {
        public void Execute(GeneratorExecutionContext context) {
            // Code generation goes here

            //            // 获取所有带有 RpcContract 特性的类型
            //            IEnumerable<INamedTypeSymbol> types = context.Compilation.SyntaxTrees
            //                .SelectMany(tree => tree.GetRoot().DescendantNodes().OfType<InterfaceDeclarationSyntax>())
            //                .Select(c => context.Compilation.GetSemanticModel(c.SyntaxTree).GetDeclaredSymbol(c))
            //                .OfType<INamedTypeSymbol>()
            //                .Where(t => t.Interfaces.Any(u=>u.Name == "IRPCService"));

            //            // 生成服务端和客户端的代码
            //            foreach (INamedTypeSymbol type in types) {
            //                string name = type.Name.StartsWith("I") ? type.Name.Substring(1)+"Base" : type.Name;
            //                context.AddSource($"{name}.g.s", SourceText.From(@$"
            //using System;
            //using System.Threading.Tasks;
            //namespace {type.ContainingNamespace} {{

            //public abstract class {name} : {type.Name} {{
            //    public abstract Task<RPCResponse> Handle(RPCRequest request, CancellationToken token = default);
            //}}

            //}}
            // ", Encoding.UTF8));
            //            }



            // Find the main method
            //            var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken);

            //            // Build up the source code
            //            string source = $@"// <auto-generated/>
            //using System;

            //namespace {mainMethod.ContainingNamespace.ToDisplayString()}
            //{{
            //    public static partial class {mainMethod.ContainingType.Name}
            //    {{
            //        static partial void HelloFrom(string name) =>
            //            Console.WriteLine($""Generator says: Hi from '{{name}}'"");
            //    }}
            //}}
            //";
            //            var typeName = mainMethod.ContainingType.Name;

            //            // Add the source code to the compilation
            //            context.AddSource($"{typeName}.g.cs", source);

            if (context.SyntaxReceiver is InterfaceSyntaxReceiver receiver) {
                foreach (InterfaceDeclarationSyntax item in receiver.CandidateInterfaces) {
                    string name = item.Identifier.Text.StartsWith("I") ? item.Identifier.Text.Substring(1) + "Base" : item.Identifier.Text;
                    string namespaceName = ((NamespaceDeclarationSyntax)item.Parent).Name.ToString();
                    context.AddSource($"{name}.g.s", SourceText.From(@$"
using System;
using System.Threading.Tasks;
namespace {namespaceName} {{
    public abstract partial class {name} : {item.Identifier.Text} {{
        public virtual Task Handle(RPCRequest request,IServerStreamWriter responseStream,CancellationToken token = default){{
             throw new NotImplementedException();
        }}
    }}
}}
                 ", Encoding.UTF8));
                }
               
            }
        }

        public void Initialize(GeneratorInitializationContext context) {
            // No initialization required for this one
            context.RegisterForSyntaxNotifications(() => new InterfaceSyntaxReceiver());
        }
    }
}
